(* --------------------------------------------------------------------
 * Copyright (c) - 2012--2016 - IMDEA Software Institute
 * Copyright (c) - 2012--2017 - Inria
 *
 * Distributed under the terms of the CeCILL-B-V1 license
 * -------------------------------------------------------------------- *)

(*** (Unnecessary) stuff about pseudo-random functions **)
require import DBool.
require import Int.
require import IntExtra.
require import Real.
require import List.
require import ListExt.
require import Distr.
require import SmtMap.
require import FSet.

require (* -- *) NewPRF.
require (* -- *) IdealPRF.

type K.
type D.
type R.

op dK: { K distr | is_lossless dK } as dKey_ll.
op dR: { R distr | is_lossless dR } as dRange_ll.
op dD: D distr.

clone import NewPRF as PRF with
  type K <- K,
  type D <- D,
  type R <- R,

  op dK <- dK

rename "PRF_Distinguisher" as "PRFDist"
rename "PRF_Oracles" as "PRFOracle"
rename "PRF_Oracle" as "PRFOracleAccess"
rename "IND" as "IndPRF".

clone import IdealPRF as PRFi with
  type K <- K,
  type D <- D,
  type R <- R,

  op dK <- dK,
  op dR <- dR
rename "RandomFunction" as "RF"
rename "PRF_Distinguisher" as "PRFDist"
rename "PRF_Oracles" as "PRFOracle"
rename "PRF_Oracle" as "PRFOracleAccess"
rename "IND" as "IndPRF".

theory PRFOracle.
  module PRFO(F: PRF): PRFOracle = {
    var k: K

    proc init(): unit = {
      k <@ F.keygen();
    }

    proc f(x: D): R = {
      var y;

      y <@ F.f(k, x);

      return y;
    }
  }.
end PRFOracle.

(* Keyed random function *)
module RandomKeyedFunction: PRF = {
  var m: (K * D, R) fmap

  proc init(): unit = {
    m <- empty;
  }

  proc keygen(): K = {
    var k;

    k <$ dK;

    return k;
  }

  proc f(k: K, x: D): R = {
    if (!(dom m (k, x))) {
      m.[(k, x)] <$ dR;
    }

    return oget m.[(k,x)];
  }
}.

(* Instantiate one oracle for each PRF to compare *)
clone import PRFOracle as PRFO1
rename "PRFO" as "PRFO1".
clone import PRFOracle as PRFO2
rename "PRFO" as "PRFO2".

(* Encapsulating the IND experiment as a direct comparison of two oracles (both emulated by O), each using different PRF *)
module PRFExp(F1: PRF, F2: PRF, D: PRFDist) = {
  proc game(real: bool) : bool = {
    var g;

    if (real) {
      PRFO1(F1).init();
      g <@ D(PRFO1(F1)).distinguish();
    } else {
      PRFO2(F2).init();
      g <@ D(PRFO2(F2)).distinguish();
    }

    return g;
  }

  proc main(): bool = {
    var b, b';
    
    b  <$ {0,1};
    b' <@ game(b);

    return b = b';
  }
}.

section PRFSecurity.
  (* Losslessness *)
  lemma prfo1_init_ll (F<: PRF) (D<: PRFDist):
    islossless F.keygen =>
    islossless PRFO1(F).init
  by move => Fkeygen_ll; proc; call Fkeygen_ll; skip; progress.

  lemma prfo1_f_ll (F<: PRF) (D<: PRFDist):
    islossless F.f =>
    islossless PRFO1(F).f
  by move => Ff_ll; proc; call Ff_ll; skip; progress; trivial.

  lemma prfo2_init_ll (F<: PRF) (D<: PRFDist):
    islossless F.keygen =>
    islossless PRFO2(F).init
  by move => Fkeygen_ll; proc; call Fkeygen_ll; skip; progress.

  lemma prfo2_f_ll (F<: PRF) (D<: PRFDist):
    islossless F.f =>
    islossless PRFO2(F).f
  by move => Ff_ll; proc; call Ff_ll; skip; progress; trivial.

  lemma prfexp_game_ll (F1<: PRF) (F2<: PRF) (D<: PRFDist):
    islossless F1.keygen =>
    islossless F2.keygen =>
    islossless D(PRFO1(F1)).distinguish => (* implies that if PRFO1.f is called, it also terminates *)
    islossless D(PRFO2(F2)).distinguish =>
    islossless PRFExp(F1, F2, D).game.
  proof.
    move => F1keygen_ll F2keygen_ll Ddistinguish1_ll Ddistinguish2_ll.
    have o1_init_ll: islossless PRFO1(F1).init by apply (prfo1_init_ll F1 D).
    have o2_init_ll: islossless PRFO2(F2).init by apply (prfo2_init_ll F2 D).
    proc => //.
    if => //.
      (* real *)
      call Ddistinguish1_ll; call o1_init_ll; wp; skip; trivial.
      (* !real *)
      call Ddistinguish2_ll; call o2_init_ll; wp; skip; trivial.
  qed.

  lemma prfexp_main_ll (F1<: PRF) (F2<: PRF) (D<: PRFDist):
    islossless F1.keygen =>
    islossless F2.keygen =>
    islossless D(PRFO1(F1)).distinguish => (* implies that if PRFO1.f is called, it also terminates *)
    islossless D(PRFO2(F2)).distinguish =>
    islossless PRFExp(F1, F2, D).main.
  proof.
    move => F1keygen_ll F2keygen_ll Ddistinguish1_ll Ddistinguish2_ll.
    have game_ll: islossless PRFExp(F1, F2, D).game by apply (prfexp_game_ll F1 F2 D).
    proc; call game_ll; rnd; skip; progress; apply (dboolE predT).
  qed.

  lemma prfind_main_ll (O<: PRFOracle) (D<: PRFDist):
    islossless O.init =>
    islossless D(O).distinguish =>
    islossless IndPRF(O, D).main.
  proof.
    move => Oinit_ll Ddistinguish1_ll; proc.
    call Ddistinguish1_ll; call Oinit_ll; skip; trivial.
  qed.

  (* We show that the previous is just some identical rewriting of IND; we do this through the definition of the advantage *)
  (*
   * Total probability
   * Pr[Main] = 1/2 Pr[Real] + 1/2 Pr[!Ideal]
   *)
  lemma prfexp_total_probability (F1<: PRF{PRFO1}) (F2<: PRF{PRFO2}) (D<: PRFDist{F1, F2, PRFO1, PRFO2}) &m:
    Pr[PRFExp(F1, F2, D).main() @ &m : res] = 1%r/2%r * (Pr[PRFExp(F1, F2, D).game(true) @ &m : res] + Pr[PRFExp(F1, F2, D).game(false) @ &m : !res]).
  proof.
    pose prReal := Pr[PRFExp(F1, F2, D).game(true) @ &m : res].
    pose prIdeal := Pr[PRFExp(F1, F2, D).game(false) @ &m : !res].
    byphoare (_: (glob D, glob F1, glob F2, glob PRFO1, glob PRFO2) = (glob D, glob F1, glob F2, glob PRFO1, glob PRFO2){m} ==> _) => //; proc => //.
    seq 1: (b) (1%r/2%r) prReal (1%r/2%r) prIdeal ((glob D, glob F1, glob F2, glob PRFO1, glob PRFO2) = (glob D, glob F1, glob F2, glob PRFO1, glob PRFO2){m}).
      rnd; wp; skip; smt.
      (* post = b *)
      rnd; wp; skip; smt.
      rewrite /prReal.
        (* b *)
        call (_: (glob D, glob F1, glob PRFO1) = (glob D, glob F1, glob PRFO1){m} /\ real ==> res) => //; last by skip; progress; smt.
        bypr; progress; rewrite H2.
        byequiv (_: ={real, glob D, glob F1, glob PRFO1} /\ real{1} ==> _) => //; proc; rcondt{1} 1 => //; rcondt{2} 1 => //; sim. 
      (* post = !b *)
      rnd; wp; skip; smt.
      rewrite /prIdeal.
        (* !b *)
        call (_: (glob D, glob F2, glob PRFO2) = (glob D, glob F2, glob PRFO2){m} /\ !real ==> !res) => //; last by skip; progress; smt.
        bypr; progress. rewrite H2.
        byequiv (_: ={real, glob D, glob F2, glob PRFO2} /\ !real{1} ==> _) => //; proc; rcondf{1} 1 => //; rcondf{2} 1 => //; sim.
    progress; smt.
  qed.

  (*
  *  Advantage: |2*Pr[Main] - 1| = Pr[Real] - Pr[Ideal]
  *)
  lemma prfexp_advantage (F1<: PRF{PRFO1}) (F2<: PRF{PRFO2}) (D<: PRFDist{F1, F2, PRFO1, PRFO2}) &m:
    islossless F1.keygen =>
    islossless F2.keygen =>
    islossless D(PRFO1(F1)).distinguish => (* implies that if PRFO1.f is called, it also terminates *)
    islossless D(PRFO2(F2)).distinguish =>
    2%r * Pr[PRFExp(F1, F2, D).main() @ &m : res] - 1%r =
    Pr[PRFExp(F1, F2, D).game(true) @ &m : res] - Pr[PRFExp(F1, F2, D).game(false) @ &m : res].
  proof.
    move => F1keygen_ll F2keygen_ll Ddistinguish1_ll Ddistinguish2_ll.
    pose prReal := Pr[PRFExp(F1, F2, D).game(true) @ &m : res].
    have ->: Pr[PRFExp(F1, F2, D).game(false) @ &m : res] = 1%r - Pr[PRFExp(F1, F2, D).game(false) @ &m : !res].
      rewrite Pr [mu_not].
      have ->: Pr[PRFExp(F1, F2, D).game(false) @ &m : true] = 1%r.
        byphoare => //; apply (prfexp_game_ll F1 F2 D) => //.
      smt.
    pose prIdeal := Pr[PRFExp(F1, F2, D).game(false) @ &m : !res].
    pose prMain := Pr[PRFExp(F1, F2, D).main() @ &m : res].
    have ->: (2%r * prMain - 1%r = prReal - (1%r - prIdeal)) = (2%r * prMain = prReal - (1%r - prIdeal) + 1%r) by smt.
    have ->: (2%r * prMain = prReal - (1%r - prIdeal) + 1%r) = (2%r * prMain = prReal - 1%r + prIdeal + 1%r) by smt.
    have ->: (2%r * prMain = prReal - 1%r + prIdeal + 1%r) = (2%r * prMain = prReal + prIdeal) by smt.
    have eqmul: forall a b, a = b <=> a * inv 2%r = b * inv 2%r by (have half0: inv 2%r <> 0%r by smt); smt.
    have ->: (2%r * prMain = prReal + prIdeal) = (2%r * prMain * inv 2%r = (prReal + prIdeal) * inv 2%r) by rewrite eqmul //.
    have ->: (2%r * prMain / 2%r = (prReal + prIdeal) / 2%r) = (prMain = (prReal + prIdeal) * inv 2%r) by smt.
    have ->: (prMain = (prReal + prIdeal) * inv 2%r) = (prMain = 1%r/2%r * (prReal + prIdeal)) by smt.
    apply (prfexp_total_probability F1 F2 D &m).
  qed.

  local lemma prfexp_real_ind1_eq (F1<: PRF{PRFO1}) (F2<: PRF) (D<: PRFDist{F1, F2, PRFO1}) &m:
    Pr[PRFExp(F1, F2, D).game(true) @ &m : res] = Pr[IndPRF(PRFO1(F1), D).main() @ &m : res].
  proof.
    byequiv => //; proc.
    rcondt{1} 1; first by progress.
    sim.
  qed.

  local lemma prfexp_ideal_ind2_eq (F1<: PRF) (F2<: PRF{PRFO2}) (D<: PRFDist{F1, F2, PRFO2}) &m:
    Pr[PRFExp(F1, F2, D).game(false) @ &m : res] = Pr[IndPRF(PRFO2(F2), D).main() @ &m : res].
  proof.
    byequiv => //; proc.
    rcondf{1} 1; first by progress.
    sim.
  qed.

  lemma prfexp_advantage_ind (F1<: PRF{PRFO1}) (F2<: PRF{PRFO2}) (D<: PRFDist{F1, F2, PRFO1, PRFO2}) &m:
    islossless F1.keygen =>
    islossless F2.keygen =>
    islossless D(PRFO1(F1)).distinguish =>
    islossless D(PRFO2(F2)).distinguish =>
    2%r * Pr[PRFExp(F1, F2, D).main() @ &m : res] - 1%r =
    Pr[IndPRF(PRFO1(F1), D).main() @ &m : res] - Pr[IndPRF(PRFO2(F2), D).main() @ &m : res].
  proof.
    move => F1keygen_ll F2keygen_ll Ddistinguish1_ll Ddistinguish2_ll.
    have ind2_main_ll: islossless IndPRF(PRFO2(F2), D).main by apply (prfind_main_ll (PRFO2(F2)) D) => //; apply (prfo2_init_ll F2 D) => //.
    rewrite - (prfexp_real_ind1_eq F1 F2 D &m).
    rewrite - (prfexp_ideal_ind2_eq F1 F2 D &m).
    apply (prfexp_advantage F1 F2 D &m) => //.
  qed.

  lemma prfexp_advantage_ind_alt (F1<: PRF{PRFO1}) (F2<: PRF{PRFO2}) (D<: PRFDist{F1, F2, PRFO1, PRFO2}) negligible &m:
    islossless F1.keygen =>
    islossless F2.keygen =>
    islossless D(PRFO1(F1)).distinguish =>
    islossless D(PRFO2(F2)).distinguish =>
    Pr[IndPRF(PRFO1(F1), D).main() @ &m : res] - Pr[IndPRF(PRFO2(F2), D).main() @ &m : res] = negligible =>
    Pr[PRFExp(F1, F2, D).main() @ &m : res] = inv 2%r + inv 2%r * negligible.
  proof.
    move => F1keygen_ll F2keygen_ll Ddistinguish1_ll Ddistinguish2_ll.
    have ind2_main_ll: islossless IndPRF(PRFO2(F2), D).main by apply (prfind_main_ll (PRFO2(F2)) D) => //; apply (prfo2_init_ll F2 D) => //.
    pose prM := Pr[PRFExp(F1, F2, D).main() @ &m : res];
    pose prR := Pr[IndPRF(PRFO1(F1), D).main() @ &m : res];
    pose prI := Pr[IndPRF(PRFO2(F2), D).main() @ &m : res].
    move => PRFassumption.
    have ->: prM = inv 2%r + inv 2%r * negligible <=> 2%r * prM - 1%r = negligible by split; smt.
    rewrite (prfexp_advantage_ind F1 F2 D &m) => //.
  qed.

  (*
   * Show that the keyed random function and the random function are indistinguishable, if
   *  - the attacker share the same internal state (its global environment) in both memories,
   *  - the RKF is empty in both memories (only to enforce prob distro to elements), and
   *  - the attacker does not have access to the internal of the functions and the oracle (obviously).
   *)
  lemma ind_rf_inf_rkf_eq (D<: PRFDist{RF,RandomKeyedFunction,PRFO2}) &m:
    equiv[IndPRF(RF, D).main ~ IndPRF(PRFO2(RandomKeyedFunction), D).main : ={glob D} /\ RandomKeyedFunction.m{2} = empty /\ RF.m{1} = empty ==> ={res}].
  proof.
    proc; inline*.
    call (_: forall x, RF.m{1}.[x] = RandomKeyedFunction.m{2}.[(PRFO2.k{2}, x)]).
    + proc. inline*. sp; wp; if; first by progress; move : (H x{2}); smt.
      + (* else *) rnd; skip; progress; smt.
    + skip; progress; smt.
    wp; rnd{2}; skip; progress; smt.
  qed.

end section PRFSecurity.

print prfexp_advantage_ind_alt.
print ind_rf_inf_rkf_eq.
