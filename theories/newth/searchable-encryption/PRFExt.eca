(* --------------------------------------------------------------------
 * Copyright (c) - 2012--2016 - IMDEA Software Institute
 * Copyright (c) - 2012--2017 - Inria
 *
 * Distributed under the terms of the CeCILL-B-V1 license
 * -------------------------------------------------------------------- *)

(*** (Unnecessary) stuff about pseudo-random functions **)
require import DBool.
require import Int.
require import IntExtra.
require import Real.
require import List.
require import ListExt.
require import Distr.
require import SmtMap.
require import FSet.

require (* -- *) NewPRF.
require (* -- *) IdealPRF.

(* bound *)
op q: { int | 0 <= q } as q_ge0.

type K.
type D.
type R.

op dK: { K distr | is_lossless dK } as dKey_ll.
op dR: { R distr | is_lossless dR } as dRange_ll.
op dD: D distr.

clone import NewPRF as PRF with
  type K <- K,
  type D <- D,
  type R <- R,

  op dK <- dK

rename "PRF_Distinguisher" as "PRFDist"
rename "PRF_Oracles" as "PRFOracle"
rename "PRF_Oracle" as "PRFOracleAccess"
rename "IND" as "IndPRF".

clone import IdealPRF as PRFi with
  type K <- K,
  type D <- D,
  type R <- R,

  op dK <- dK,
  op dR <- dR
rename "RandomFunction" as "SimpleRF"
rename "PRF_Distinguisher" as "PRFDist"
rename "PRF_Oracles" as "PRFOracle"
rename "PRF_Oracle" as "PRFOracleAccess"
rename "IND" as "IndPRF".

module RF = {
  var collisions: bool
  var m: (D, R) fmap

  proc init() = {
    m <- empty;
    collisions <- false;
  }

  proc f(x: D): R = {
    var v;

    if (!dom m x) {
      v <$ dR;
      collisions <- collisions \/ rng m v;
      m.[x] <- v;
    }

    return oget m.[x];
  }
}.

theory PRFOracle.
  module PRFO(F: PRF): PRFOracle = {
    var k: K

    proc init(): unit = {
      k <@ F.keygen();
    }

    proc f(x: D): R = {
      var y;

      y <@ F.f(k, x);

      return y;
    }
  }.
end PRFOracle.

(* Keyed random function *)
module RandomKeyedFunction: PRF = {
  var m: (K * D, R) fmap

  proc init(): unit = {
    m <- empty;
  }

  proc keygen(): K = {
    var k;

    k <$ dK;

    return k;
  }

  proc f(k: K, x: D): R = {
    if (!(dom m (k, x))) {
      m.[(k, x)] <$ dR;
    }

    return oget m.[(k,x)];
  }
}.

(* Instantiate one oracle for each PRF to compare *)
clone import PRFOracle as PRFO1
rename "PRFO" as "PRFO1".
clone import PRFOracle as PRFO2
rename "PRFO" as "PRFO2".

(* Encapsulating the IND experiment as a direct comparison of two oracles (both emulated by O), each using different PRF *)
module PRFExp(F1: PRF, F2: PRF, D: PRFDist) = {
  proc game(real: bool) : bool = {
    var g;

    if (real) {
      PRFO1(F1).init();
      g <@ D(PRFO1(F1)).distinguish();
    } else {
      PRFO2(F2).init();
      g <@ D(PRFO2(F2)).distinguish();
    }

    return g;
  }

  proc main(): bool = {
    var b, b';
    
    b  <$ {0,1};
    b' <@ game(b);

    return b = b';
  }
}.

section PRFSecurity.
  (* Losslessness *)
  lemma prfo1_init_ll (F<: PRF) (D<: PRFDist):
    islossless F.keygen =>
    islossless PRFO1(F).init
  by move => Fkeygen_ll; proc; call Fkeygen_ll; skip; progress.

  lemma prfo1_f_ll (F<: PRF) (D<: PRFDist):
    islossless F.f =>
    islossless PRFO1(F).f
  by move => Ff_ll; proc; call Ff_ll; skip; progress; trivial.

  lemma prfo2_init_ll (F<: PRF) (D<: PRFDist):
    islossless F.keygen =>
    islossless PRFO2(F).init
  by move => Fkeygen_ll; proc; call Fkeygen_ll; skip; progress.

  lemma prfo2_f_ll (F<: PRF) (D<: PRFDist):
    islossless F.f =>
    islossless PRFO2(F).f
  by move => Ff_ll; proc; call Ff_ll; skip; progress; trivial.

  lemma prfexp_game_ll (F1<: PRF) (F2<: PRF) (D<: PRFDist):
    islossless F1.keygen =>
    islossless F2.keygen =>
    islossless D(PRFO1(F1)).distinguish => (* implies that if PRFO1.f is called, it also terminates *)
    islossless D(PRFO2(F2)).distinguish =>
    islossless PRFExp(F1, F2, D).game.
  proof.
    move => F1keygen_ll F2keygen_ll Ddistinguish1_ll Ddistinguish2_ll.
    have o1_init_ll: islossless PRFO1(F1).init by apply (prfo1_init_ll F1 D).
    have o2_init_ll: islossless PRFO2(F2).init by apply (prfo2_init_ll F2 D).
    proc => //.
    if => //.
      (* real *)
      call Ddistinguish1_ll; call o1_init_ll; wp; skip; trivial.
      (* !real *)
      call Ddistinguish2_ll; call o2_init_ll; wp; skip; trivial.
  qed.

  lemma prfexp_main_ll (F1<: PRF) (F2<: PRF) (D<: PRFDist):
    islossless F1.keygen =>
    islossless F2.keygen =>
    islossless D(PRFO1(F1)).distinguish => (* implies that if PRFO1.f is called, it also terminates *)
    islossless D(PRFO2(F2)).distinguish =>
    islossless PRFExp(F1, F2, D).main.
  proof.
    move => F1keygen_ll F2keygen_ll Ddistinguish1_ll Ddistinguish2_ll.
    have game_ll: islossless PRFExp(F1, F2, D).game by apply (prfexp_game_ll F1 F2 D).
    proc; call game_ll; rnd; skip; progress; apply (dboolE predT).
  qed.

  lemma prfind_main_ll (O<: PRFOracle) (D<: PRFDist):
    islossless O.init =>
    islossless D(O).distinguish =>
    islossless IndPRF(O, D).main.
  proof.
    move => Oinit_ll Ddistinguish1_ll; proc.
    call Ddistinguish1_ll; call Oinit_ll; skip; trivial.
  qed.

  (* We show that the previous is just some identical rewriting of IND; we do this through the definition of the advantage *)
  (*
   * Total probability
   * Pr[Main] = 1/2 Pr[Real] + 1/2 Pr[!Ideal]
   *)
  lemma prfexp_total_probability (F1<: PRF{PRFO1}) (F2<: PRF{PRFO2}) (D<: PRFDist{F1, F2, PRFO1, PRFO2}) &m:
    Pr[PRFExp(F1, F2, D).main() @ &m : res] = 1%r/2%r * (Pr[PRFExp(F1, F2, D).game(true) @ &m : res] + Pr[PRFExp(F1, F2, D).game(false) @ &m : !res]).
  proof.
    pose prReal := Pr[PRFExp(F1, F2, D).game(true) @ &m : res].
    pose prIdeal := Pr[PRFExp(F1, F2, D).game(false) @ &m : !res].
    byphoare (_: (glob D, glob F1, glob F2, glob PRFO1, glob PRFO2) = (glob D, glob F1, glob F2, glob PRFO1, glob PRFO2){m} ==> _) => //; proc => //.
    seq 1: (b) (1%r/2%r) prReal (1%r/2%r) prIdeal ((glob D, glob F1, glob F2, glob PRFO1, glob PRFO2) = (glob D, glob F1, glob F2, glob PRFO1, glob PRFO2){m}).
      rnd; wp; skip; smt.
      (* post = b *)
      rnd; wp; skip; smt.
      rewrite /prReal.
        (* b *)
        call (_: (glob D, glob F1, glob PRFO1) = (glob D, glob F1, glob PRFO1){m} /\ real ==> res) => //; last by skip; progress; smt.
        bypr; progress; rewrite H2.
        byequiv (_: ={real, glob D, glob F1, glob PRFO1} /\ real{1} ==> _) => //; proc; rcondt{1} 1 => //; rcondt{2} 1 => //; sim. 
      (* post = !b *)
      rnd; wp; skip; smt.
      rewrite /prIdeal.
        (* !b *)
        call (_: (glob D, glob F2, glob PRFO2) = (glob D, glob F2, glob PRFO2){m} /\ !real ==> !res) => //; last by skip; progress; smt.
        bypr; progress. rewrite H2.
        byequiv (_: ={real, glob D, glob F2, glob PRFO2} /\ !real{1} ==> _) => //; proc; rcondf{1} 1 => //; rcondf{2} 1 => //; sim.
    progress; smt.
  qed.

  (*
  *  Advantage: |2*Pr[Main] - 1| = Pr[Real] - Pr[Ideal]
  *)
  lemma prfexp_advantage (F1<: PRF{PRFO1}) (F2<: PRF{PRFO2}) (D<: PRFDist{F1, F2, PRFO1, PRFO2}) &m:
    islossless F1.keygen =>
    islossless F2.keygen =>
    islossless D(PRFO1(F1)).distinguish => (* implies that if PRFO1.f is called, it also terminates *)
    islossless D(PRFO2(F2)).distinguish =>
    2%r * Pr[PRFExp(F1, F2, D).main() @ &m : res] - 1%r =
    Pr[PRFExp(F1, F2, D).game(true) @ &m : res] - Pr[PRFExp(F1, F2, D).game(false) @ &m : res].
  proof.
    move => F1keygen_ll F2keygen_ll Ddistinguish1_ll Ddistinguish2_ll.
    pose prReal := Pr[PRFExp(F1, F2, D).game(true) @ &m : res].
    have ->: Pr[PRFExp(F1, F2, D).game(false) @ &m : res] = 1%r - Pr[PRFExp(F1, F2, D).game(false) @ &m : !res].
      rewrite Pr [mu_not].
      have ->: Pr[PRFExp(F1, F2, D).game(false) @ &m : true] = 1%r.
        byphoare => //; apply (prfexp_game_ll F1 F2 D) => //.
      smt.
    pose prIdeal := Pr[PRFExp(F1, F2, D).game(false) @ &m : !res].
    pose prMain := Pr[PRFExp(F1, F2, D).main() @ &m : res].
    have ->: (2%r * prMain - 1%r = prReal - (1%r - prIdeal)) = (2%r * prMain = prReal - (1%r - prIdeal) + 1%r) by smt.
    have ->: (2%r * prMain = prReal - (1%r - prIdeal) + 1%r) = (2%r * prMain = prReal - 1%r + prIdeal + 1%r) by smt.
    have ->: (2%r * prMain = prReal - 1%r + prIdeal + 1%r) = (2%r * prMain = prReal + prIdeal) by smt.
    have eqmul: forall a b, a = b <=> a * inv 2%r = b * inv 2%r by (have half0: inv 2%r <> 0%r by smt); smt.
    have ->: (2%r * prMain = prReal + prIdeal) = (2%r * prMain * inv 2%r = (prReal + prIdeal) * inv 2%r) by rewrite eqmul //.
    have ->: (2%r * prMain / 2%r = (prReal + prIdeal) / 2%r) = (prMain = (prReal + prIdeal) * inv 2%r) by smt.
    have ->: (prMain = (prReal + prIdeal) * inv 2%r) = (prMain = 1%r/2%r * (prReal + prIdeal)) by smt.
    apply (prfexp_total_probability F1 F2 D &m).
  qed.

  local lemma prfexp_real_ind1_eq (F1<: PRF{PRFO1}) (F2<: PRF) (D<: PRFDist{F1, F2, PRFO1}) &m:
    Pr[PRFExp(F1, F2, D).game(true) @ &m : res] = Pr[IndPRF(PRFO1(F1), D).main() @ &m : res].
  proof.
    byequiv => //; proc.
    rcondt{1} 1; first by progress.
    sim.
  qed.

  local lemma prfexp_ideal_ind2_eq (F1<: PRF) (F2<: PRF{PRFO2}) (D<: PRFDist{F1, F2, PRFO2}) &m:
    Pr[PRFExp(F1, F2, D).game(false) @ &m : res] = Pr[IndPRF(PRFO2(F2), D).main() @ &m : res].
  proof.
    byequiv => //; proc.
    rcondf{1} 1; first by progress.
    sim.
  qed.

  lemma prfexp_advantage_ind (F1<: PRF{PRFO1}) (F2<: PRF{PRFO2}) (D<: PRFDist{F1, F2, PRFO1, PRFO2}) &m:
    islossless F1.keygen =>
    islossless F2.keygen =>
    islossless D(PRFO1(F1)).distinguish =>
    islossless D(PRFO2(F2)).distinguish =>
    2%r * Pr[PRFExp(F1, F2, D).main() @ &m : res] - 1%r =
    Pr[IndPRF(PRFO1(F1), D).main() @ &m : res] - Pr[IndPRF(PRFO2(F2), D).main() @ &m : res].
  proof.
    move => F1keygen_ll F2keygen_ll Ddistinguish1_ll Ddistinguish2_ll.
    have ind2_main_ll: islossless IndPRF(PRFO2(F2), D).main by apply (prfind_main_ll (PRFO2(F2)) D) => //; apply (prfo2_init_ll F2 D) => //.
    rewrite - (prfexp_real_ind1_eq F1 F2 D &m).
    rewrite - (prfexp_ideal_ind2_eq F1 F2 D &m).
    apply (prfexp_advantage F1 F2 D &m) => //.
  qed.

  lemma prfexp_advantage_ind_alt (F1<: PRF{PRFO1}) (F2<: PRF{PRFO2}) (D<: PRFDist{F1, F2, PRFO1, PRFO2}) negligible &m:
    islossless F1.keygen =>
    islossless F2.keygen =>
    islossless D(PRFO1(F1)).distinguish =>
    islossless D(PRFO2(F2)).distinguish =>
    Pr[IndPRF(PRFO1(F1), D).main() @ &m : res] - Pr[IndPRF(PRFO2(F2), D).main() @ &m : res] = negligible =>
    Pr[PRFExp(F1, F2, D).main() @ &m : res] = inv 2%r + inv 2%r * negligible.
  proof.
    move => F1keygen_ll F2keygen_ll Ddistinguish1_ll Ddistinguish2_ll.
    have ind2_main_ll: islossless IndPRF(PRFO2(F2), D).main by apply (prfind_main_ll (PRFO2(F2)) D) => //; apply (prfo2_init_ll F2 D) => //.
    pose prM := Pr[PRFExp(F1, F2, D).main() @ &m : res];
    pose prR := Pr[IndPRF(PRFO1(F1), D).main() @ &m : res];
    pose prI := Pr[IndPRF(PRFO2(F2), D).main() @ &m : res].
    move => PRFassumption.
    have ->: prM = inv 2%r + inv 2%r * negligible <=> 2%r * prM - 1%r = negligible by split; smt.
    rewrite (prfexp_advantage_ind F1 F2 D &m) => //.
  qed.

  (*
   * Show that the keyed random function and the random function are indistinguishable, if
   *  - the attacker share the same internal state (its global environment) in both memories,
   *  - the RKF is empty in both memories (only to enforce prob distro to elements), and
   *  - the attacker does not have access to the internal of the functions and the oracle (obviously).
   *)
  lemma ind_rf_inf_rkf_eq (D<: PRFDist{RF,RandomKeyedFunction,PRFO2}) &m:
    equiv[IndPRF(RF, D).main ~ IndPRF(PRFO2(RandomKeyedFunction), D).main : ={glob D} /\ RandomKeyedFunction.m{2} = empty /\ RF.m{1} = empty ==> ={res}].
  proof.
    proc; inline*.
    call (_: forall x, RF.m{1}.[x] = RandomKeyedFunction.m{2}.[(PRFO2.k{2}, x)]).
    + proc. inline*. sp; wp; if; first by progress; move : (H x{2}); smt.
      + (* else *) wp; rnd; skip; progress; smt.
    + skip; progress; smt.
    wp; rnd{2}; skip; progress; smt.
  qed.

end section PRFSecurity.

section PRFCollisions.
  (*
   * BoundedRRFD contains an attacker and a bounded function counter
   * wrapping the random function RF that is aware of
   * how many times it has been called on f.
   *)
  module BoundedRFD(D: PRFDist, OA: PRFOracleAccess) = {
    var calls: int

    module BRF = {
      proc init() = {
        RF.init();
        calls <- 0;
      }

      proc f(x: D): R = {
        var v = witness;

        if (calls < q) {
          (* elements in m less than q *)
          if (card (frng RF.m) < q) {
            v <- RF.f(x);
          }
          calls <- calls + 1;
        }

        return v;
      }
    }

    proc distinguish() = {
      var b;

      BRF.init();
      b <@ D(BRF).distinguish();

      return b;
    }
  }.

  (*
   * We can distinguish between the two as soon as either
   * - we find a collision, or
   * - we reach the maximum number of allowed calls.
   * (adaptation to random function from random permutations)
   *)
  require import FelTactic.
  require import SmtMapExt.
  require import Mu_mem.
  (*---*) import StdBigop StdRing StdOrder IntExtra RealExtra.
  (*---*) import Bigreal.BRA RField RField.AddMonoid IntOrder.

  lemma brfd_collision_bound (D<: PRFDist{RF,BoundedRFD}) &m:
    is_full dR =>
    is_uniform dR =>
    Pr[IndPRF(RF, BoundedRFD(D)).main() @ &m : RF.collisions] <= (q^2 - q)%r / 2%r * mu dR (pred1 witness).
  proof.
    move => dR_fu dR_un.
    have ->:   Pr[IndPRF(RF, BoundedRFD(D)).main() @ &m : RF.collisions]
            = Pr[IndPRF(RF, BoundedRFD(D)).main() @ &m : RF.collisions /\ BoundedRFD.calls <= q].
      byequiv => //=.
      conseq (_: ={glob D} ==> ={RF.collisions, BoundedRFD.calls})
             (_: true ==> BoundedRFD.calls <= q) => //=.
      * proc; inline *; wp; call (_: BoundedRFD.calls <= q).
        - proc; inline*; sp; if => //=; auto => //; sp; if => //=; auto => //.
          * sp; if => //=; auto => /#.
          * progress; smt. 
        - wp; skip; progress; apply/q_ge0.
      * sim.
    have ->:   Pr[IndPRF(RF, BoundedRFD(D)).main() @ &m : RF.collisions /\ BoundedRFD.calls <= q]
            = Pr[BoundedRFD(D, RF).distinguish() @ &m: RF.collisions /\ BoundedRFD.calls <= q].
      byequiv=> //=; proc; inline *; wp.
      call (_: ={glob RF, BoundedRFD.calls} /\ card (frng RF.m){1} <= BoundedRFD.calls{2}).
      * proc; inline*; sp; if=> //=; sp; if => //.
        - sp; if => //.
          + wp; rnd; skip; progress.
            apply/(ler_trans (card (frng RF.m{2} `|` fset1 v0L))).
              apply/subset_leq_fcard=> x'; rewrite !inE !mem_frng !rngE=> - /= [x0].
              rewrite get_setE; case: (x0 = x{2})=> [<<- /= ->|_ mx0] //.
              by left; exists x0.
            smt.
          + wp; skip; progress; smt.
      * wp; skip; progress; smt.
      wp; skip; progress; smt.
    fel 1 BoundedRFD.calls (fun x, x%r * mu dR (pred1 witness)) q (RF.collisions) 
           [BoundedRFD(D, RF).BRF.f: (BoundedRFD.calls < q)]
           (card (fdom RF.m) <= BoundedRFD.calls) => //.
    + rewrite -mulr_suml Bigreal.sumidE 1:q_ge0. 
      by rewrite (powS 1) // pow1;smt(mu_bounded q_ge0).
    + by inline*; auto=> />; rewrite fdom0 fcards0.
    + exists* BoundedRFD.calls; elim *=> c.
      conseq(:_==>_ : (c%r * mu1 dR witness))=> />.
      proc; sp; rcondt 1=> //.
      inline *; sp; if=> //=; last first.
      * hoare; auto=> // /> &hr _ _ _ _ _ .
        by apply/RealOrder.mulr_ge0; smt w=(mu_bounded q_ge0).
      * sp; if => //=.
        + wp; rnd (rng RF.m); skip; progress.
          - apply/(RealOrder.ler_trans ((card (frng RF.m{hr}))%r * mu dR (pred1 witness))).
              have ->: rng RF.m{hr} = mem (frng RF.m{hr}) by apply/fun_ext=> x; rewrite mem_frng.
              apply/mu_mem_le.
              move=> x _; apply/RealOrder.lerr_eq.
              rewrite (dR_un x witness) => //; by rewrite dR_fu.
            by apply/RealOrder.ler_wpmul2r; smt w=(mu_bounded lt_fromint ltrW le_card_frng_fdom).
          - move: H8; rewrite H1 //.
        + by hoare; auto=> //=; smt w=(RealOrder.mulr_ge0 mu_bounded q_ge0).
    + move=> c; proc; rcondt 2; 1:by auto.
      sp; if=> //=.
      * inline*;sp;if;auto; 2:smt().
        move=> &hr /> + + + + y />.
        by rewrite !fdom_set !fcardU !fcard1; smt(fcard_ge0).
      * by auto=> /#.
    + by move=> b c; proc; rcondf 2; auto.
  qed.

end section PRFCollisions.

print prfexp_advantage_ind_alt.
print ind_rf_inf_rkf_eq.
print brfd_collision_bound.
